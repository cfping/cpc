import{p as t,q as a,r as e,A as s,u as r,v as n,w as o,x as c,e as i,y as u,z as d,C as l,D as f,E as p,F as h,b as w,I as m,B as y,G as g,s as b,H as x,J as k,a as v,K as R,L as E}from"./index-BU5zChEe.js";import"./vendor-Cf-b6fZO.js";const L="/docs/contract/encodeErrorResult";function M(t){const{abi:s,errorName:r,args:d}=t;let l=s[0];if(r){const t=n({abi:s,args:d,name:r});if(!t)throw new o(r,{docsPath:L});l=t}if("error"!==l.type)throw new o(void 0,{docsPath:L});const f=e(l),p=a(f);let h="0x";if(d&&d.length>0){if(!l.inputs)throw new c(l.name,{docsPath:L});h=i(l.inputs,d)}return u([p,h])}const O="/docs/contract/encodeFunctionResult";const P="x-batch-gateway:true";async function C(o){const{data:c,ccipRequest:u}=o,{args:[w]}=function(n){const{abi:o,data:c}=n,i=t(c,0,4),u=o.find(t=>"function"===t.type&&i===a(e(t)));if(!u)throw new s(i,{docsPath:"/docs/contract/decodeFunctionData"});return{functionName:u.name,args:"inputs"in u&&u.inputs&&u.inputs.length>0?r(u.inputs,t(c,4)):void 0}}({abi:p,data:c}),m=[],y=[];return await Promise.all(w.map(async(t,a)=>{try{y[a]=t.urls.includes(P)?await C({data:t.data,ccipRequest:u}):await u(t),m[a]=!1}catch(s){m[a]=!0,y[a]="HttpRequestError"===(e=s).name&&e.status?M({abi:p,errorName:"HttpError",args:[e.status,e.shortMessage]}):M({abi:[h],errorName:"Error",args:["shortMessage"in e?e.shortMessage:e.message]})}var e})),function(t){const{abi:a,functionName:e,result:s}=t;let r=a[0];if(e){const t=n({abi:a,name:e});if(!t)throw new d(e,{docsPath:O});r=t}if("function"!==r.type)throw new d(void 0,{docsPath:O});if(!r.outputs)throw new l(r.name,{docsPath:O});const o=(()=>{if(0===r.outputs.length)return[];if(1===r.outputs.length)return[s];if(Array.isArray(s))return s;throw new f(s)})();return i(r.outputs,o)}({abi:p,functionName:"query",result:[m,y]})}class N extends y{constructor({callbackSelector:t,cause:a,data:e,extraData:s,sender:r,urls:n}){var o;super(a.shortMessage||"An error occurred while fetching for an offchain result.",{cause:a,metaMessages:[...a.metaMessages||[],(null==(o=a.metaMessages)?void 0:o.length)?"":[],"Offchain Gateway Call:",n&&["  Gateway URL(s):",...n.map(t=>"    ".concat(g(t)))],"  Sender: ".concat(r),"  Data: ".concat(e),"  Callback selector: ".concat(t),"  Extra data: ".concat(s)].flat(),name:"OffchainLookupError"})}}class T extends y{constructor({result:t,url:a}){super("Offchain gateway response is malformed. Response data must be a hex value.",{metaMessages:["Gateway URL: ".concat(g(a)),"Response: ".concat(b(t))],name:"OffchainLookupResponseMalformedError"})}}class q extends y{constructor({sender:t,to:a}){super("Reverted sender address does not match target contract address (`to`).",{metaMessages:["Contract address: ".concat(a),"OffchainLookup sender address: ".concat(t)],name:"OffchainLookupSenderMismatchError"})}}const S="0x556f1830",D={name:"OffchainLookup",type:"error",inputs:[{name:"sender",type:"address"},{name:"urls",type:"string[]"},{name:"callData",type:"bytes"},{name:"callbackFunction",type:"bytes4"},{name:"extraData",type:"bytes"}]};async function j(t,{blockNumber:a,blockTag:e,data:s,to:r}){const{args:n}=x({data:s,abi:[D]}),[o,c,u,d,l]=n,{ccipRead:f}=t,p=f&&"function"==typeof(null==f?void 0:f.request)?f.request:A;try{if(!function(t,a){if(!w(t,{strict:!1}))throw new m({address:t});if(!w(a,{strict:!1}))throw new m({address:a});return t.toLowerCase()===a.toLowerCase()}(r,o))throw new q({sender:o,to:r});const s=c.includes(P)?await C({data:u,ccipRequest:p}):await p({data:u,sender:o,urls:c}),{data:n}=await k(t,{blockNumber:a,blockTag:e,data:v([d,i([{type:"bytes"},{type:"bytes"}],[s,l])]),to:r});return n}catch(h){throw new N({callbackSelector:d,cause:h,data:s,extraData:l,sender:o,urls:c})}}async function A({data:t,sender:a,urls:e}){var s;let r=new Error("An unknown error occurred.");for(let o=0;o<e.length;o++){const c=e[o],i=c.includes("{data}")?"GET":"POST",u="POST"===i?{data:t,sender:a}:void 0,d="POST"===i?{"Content-Type":"application/json"}:{};try{const e=await fetch(c.replace("{sender}",a.toLowerCase()).replace("{data}",t),{body:JSON.stringify(u),headers:d,method:i});let n;if(n=(null==(s=e.headers.get("Content-Type"))?void 0:s.startsWith("application/json"))?(await e.json()).data:await e.text(),!e.ok){r=new R({body:u,details:(null==n?void 0:n.error)?b(n.error):e.statusText,headers:e.headers,status:e.status,url:c});continue}if(!E(n)){r=new T({result:n,url:c});continue}return n}catch(n){r=new R({body:u,details:n.message,url:c})}}throw r}export{A as ccipRequest,j as offchainLookup,D as offchainLookupAbiItem,S as offchainLookupSignature};
